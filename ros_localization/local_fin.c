/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#pragma pack(4)
#pragma pack(4)
#pragma pack(4)
#pragma pack(4)
#pragma pack(4)
#pragma pack(4)
#pragma pack(4)
#pragma pack(4)
#pragma pack(4)
#pragma pack(4)
struct nav_msgs_Odometry {
   double pose_position_x ;
   double pose_position_y ;
   double pose_position_z ;
   double pose_orientation_x ;
   double pose_orientation_y ;
   double pose_orientation_z ;
   double pose_orientation_w ;
   double pose_covariance[36] ;
   double twist_linear_x ;
   double twist_linear_y ;
   double twist_linear_z ;
   double twist_angular_x ;
   double twist_angular_y ;
   double twist_angular_z ;
   double twist_covariance[36] ;
   char *header_frame_id ;
   int header_stamp ;
   int header_seq ;
   char *child_frame_id ;
};
typedef struct nav_msgs_Odometry nav_msgs_Odometry;
#pragma pack(4)
struct geometry_msgs_Pose {
   double pose_position_x ;
   double pose_position_y ;
   double pose_position_z ;
   double pose_orientation_x ;
   double pose_orientation_y ;
   double pose_orientation_z ;
   double pose_orientation_w ;
   double pose_covariance[36] ;
   double twist_linear_x ;
   double twist_linear_y ;
   double twist_linear_z ;
   double twist_angular_x ;
   double twist_angular_y ;
   double twist_angular_z ;
   double twist_covariance[36] ;
   char *header_frame_id ;
   int header_stamp ;
   int header_seq ;
   char *child_frame_id ;
};
typedef struct geometry_msgs_Pose geometry_msgs_Pose;
#pragma pack(4)
struct geometry_msgs_Twist {
   double pose_position_x ;
   double pose_position_y ;
   double pose_position_z ;
   double pose_orientation_x ;
   double pose_orientation_y ;
   double pose_orientation_z ;
   double pose_orientation_w ;
   double pose_covariance[36] ;
   double twist_linear_x ;
   double twist_linear_y ;
   double twist_linear_z ;
   double twist_angular_x ;
   double twist_angular_y ;
   double twist_angular_z ;
   double twist_covariance[36] ;
   char *header_frame_id ;
   int header_stamp ;
   int header_seq ;
   char *child_frame_id ;
};
typedef struct geometry_msgs_Twist geometry_msgs_Twist;
#pragma pack(4)
struct sensor_msgs_Imu_Pose {
   double orientation_x ;
   double orientation_y ;
   double orientation_z ;
   double orientation_w ;
   double orientation_covariance[9] ;
   char *header_frame_id ;
   int header_stamp ;
   int header_seq ;
};
typedef struct sensor_msgs_Imu_Pose sensor_msgs_Imu_Pose;
#pragma pack(4)
struct sensor_msgs_Imu_Twist {
   double angular_velocity_x ;
   double angular_velocity_y ;
   double angular_velocity_z ;
   double angular_velocity_covariance[9] ;
   char *header_frame_id ;
   int header_stamp ;
   int header_seq ;
};
typedef struct sensor_msgs_Imu_Twist sensor_msgs_Imu_Twist;
#pragma pack(4)
struct sensor_msgs_Imu_Acc {
   double linear_acceleration_x ;
   double linear_acceleration_y ;
   double linear_acceleration_z ;
   double linear_acceleration_covariance[9] ;
   char *header_frame_id ;
   int header_stamp ;
   int header_seq ;
};
typedef struct sensor_msgs_Imu_Acc sensor_msgs_Imu_Acc;
#pragma pack(4)
struct sensor_msgs_Imu {
   double orientation_x ;
   double orientation_y ;
   double orientation_z ;
   double orientation_w ;
   double orientation_covariance[9] ;
   double angular_velocity_covariance[9] ;
   char *header_frame_id ;
   int header_stamp ;
   int header_seq ;
};
typedef struct sensor_msgs_Imu sensor_msgs_Imu;
#pragma pack(4)
struct ros_Publisher {
   char *topic ;
   int queuesize ;
};
typedef struct ros_Publisher ros_Publisher;
#pragma pack(4)
struct ros_Subscriber {
   char *topic ;
   int queuesize ;
};
typedef struct ros_Subscriber ros_Subscriber;
_Bool stateUpdated_  ;
double M_PI  =    3.141592;
int mystrcmp(char const   *s , char const   *t ) ;
void nh_serviceClient(void) ;
struct ros_Publisher *nh_advertise(char *topic_name , int queue_size ) ;
struct ros_Subscriber *nh_subscribe(char *topic_name , int queue_size ) ;
void Duration_sleep(double seconds ) ;
void loopRate_sleep(int fq ) ;
void publish(char *meta , int size , int sq ) ;
int mystrcmp(char const   *s , char const   *t ) 
{ 
  int i ;

  {
  i = 0;
  while ((int const   )*(s + i) == (int const   )*(t + i)) {
    if ((int const   )*(s + i) == 0) {
      return (0);
    }
    i ++;
  }
  return ((int const   )*(s + i) - (int const   )*(t + i));
}
}
void nh_serviceClient(void) 
{ 


  {
  return;
}
}
extern int ( /* missing proto */  malloc)() ;
struct ros_Publisher *nh_advertise(char *topic_name , int queue_size ) 
{ 
  struct ros_Publisher *pub ;
  struct ros_Publisher *tmp ;

  {
  tmp = (struct ros_Publisher *)malloc(sizeof(ros_Publisher ));
  pub = tmp;
  pub->topic = topic_name;
  pub->queuesize = queue_size;
  return (pub);
}
}
struct ros_Subscriber *nh_subscribe(char *topic_name , int queue_size ) 
{ 
  struct ros_Subscriber *sub ;
  struct ros_Subscriber *tmp ;

  {
  tmp = (struct ros_Subscriber *)malloc(sizeof(ros_Subscriber ));
  sub = tmp;
  sub->topic = topic_name;
  sub->queuesize = queue_size;
  return (sub);
}
}
void Duration_sleep(double seconds ) 
{ 
  double sec ;

  {
  sec = seconds;
  return;
}
}
void loopRate_sleep(int fq ) 
{ 
  int sleep_fq ;

  {
  sleep_fq = 0;
  sleep_fq = fq;
  return;
}
}
void publish(char *meta , int size , int sq ) 
{ 
  char *topic_name ;
  int topic_size ;
  int pub_seq ;

  {
  topic_name = meta;
  topic_size = size;
  pub_seq = sq;
  return;
}
}
void resetFilter(void) 
{ 


  {
  return;
}
}
extern int ( /* missing proto */  free)() ;
void OdomPoseBasicIOTEST(void) 
{ 
  int pubsize ;
  int seq ;
  nav_msgs_Odometry *odom ;
  struct nav_msgs_Odometry *tmp ;
  int i ;

  {
  stateUpdated_ = 0;
  pubsize = 0;
  seq = 1;
  tmp = (struct nav_msgs_Odometry *)malloc(sizeof(nav_msgs_Odometry ));
  odom = tmp;
  pubsize = (unsigned long )pubsize + sizeof(nav_msgs_Odometry );
  i = 0;
  while (i < 50) {
    publish("odom", pubsize, seq);
    loopRate_sleep(50);
    seq ++;
    i ++;
  }
  free(odom);
  resetFilter();
  return;
}
}
void OdomTwistBasicIOTEST(void) 
{ 
  int pubsize ;
  int seq ;
  int ind ;
  int i ;

  {
  pubsize = 0;
  seq = 1;
  pubsize = (unsigned long )pubsize + sizeof(nav_msgs_Odometry );
  ind = 0;
  while (ind < 36) {
    ind += 7;
  }
  i = 0;
  while (i < 400) {
    publish("odom", pubsize, seq);
    loopRate_sleep(20);
    seq ++;
    i ++;
  }
  i = 0;
  i = 0;
  while (i < 200) {
    publish("odom", pubsize, seq);
    loopRate_sleep(20);
    seq ++;
    i ++;
  }
  i = 0;
  i = 0;
  while (i < 100) {
    publish("odom", pubsize, seq);
    loopRate_sleep(20);
    seq ++;
    i ++;
  }
  i = 0;
  i = 0;
  while (i < 100) {
    publish("odom", pubsize, seq);
    loopRate_sleep(20);
    i ++;
  }
  i = 0;
  i = 0;
  while (i < 100) {
    publish("odom", pubsize, seq);
    loopRate_sleep(20);
    seq ++;
    i ++;
  }
  i = 0;
  i = 0;
  while (i < 100) {
    publish("odom", pubsize, seq);
    loopRate_sleep(20);
    seq ++;
    i ++;
  }
  i = 0;
  i = 0;
  while (i < 100) {
    publish("odom", pubsize, seq);
    loopRate_sleep(20);
    seq ++;
    i ++;
  }
  return;
}
}
void PoseBasicIOTEST(void) 
{ 
  int pubsize ;
  int seq ;
  struct geometry_msgs_Pose *pose___0 ;
  struct geometry_msgs_Pose *tmp ;
  int ind ;
  int i ;

  {
  pubsize = 0;
  seq = 1;
  tmp = (struct geometry_msgs_Pose *)malloc(sizeof(geometry_msgs_Pose ));
  pose___0 = tmp;
  pubsize = (unsigned long )pubsize + sizeof(geometry_msgs_Pose );
  ind = 0;
  ind = 0;
  while (ind < 36) {
    ind += 7;
  }
  i = 0;
  i = 0;
  while (i < 50) {
    publish("pose", pubsize, seq);
    loopRate_sleep(50);
    seq ++;
    i ++;
  }
  return;
}
}
void TwistBasicIOTEST(void) 
{ 
  int pubsize ;
  int seq ;
  geometry_msgs_Twist *twist___0 ;
  struct geometry_msgs_Twist *tmp ;
  int ind ;
  int i ;

  {
  pubsize = 0;
  seq = 1;
  tmp = (struct geometry_msgs_Twist *)malloc(sizeof(geometry_msgs_Twist ));
  twist___0 = tmp;
  pubsize = (unsigned long )pubsize + sizeof(geometry_msgs_Twist );
  ind = 0;
  ind = 0;
  while (ind < 36) {
    ind += 7;
  }
  i = 0;
  i = 0;
  while (i < 400) {
    publish("twist", pubsize, seq);
    loopRate_sleep(20);
    seq ++;
    i ++;
  }
  i = 0;
  while (i < 200) {
    publish("twist", pubsize, seq);
    loopRate_sleep(20);
    seq ++;
    i ++;
  }
  i = 0;
  while (i < 100) {
    publish("twist", pubsize, seq);
    loopRate_sleep(20);
    seq ++;
    i ++;
  }
  i = 0;
  while (i < 100) {
    publish("twist", pubsize, seq);
    loopRate_sleep(20);
    i ++;
  }
  i = 0;
  while (i < 100) {
    publish("twist", pubsize, seq);
    loopRate_sleep(20);
    seq ++;
    i ++;
  }
  i = 0;
  while (i < 100) {
    publish("twist", pubsize, seq);
    loopRate_sleep(20);
    seq ++;
    i ++;
  }
  i = 0;
  while (i < 100) {
    publish("twist", pubsize, seq);
    loopRate_sleep(20);
    seq ++;
    i ++;
  }
  return;
}
}
void ImuPoseBasicIOTEST(void) 
{ 
  int pubsize ;
  int seq ;
  struct sensor_msgs_Imu_Pose *imu ;
  struct sensor_msgs_Imu_Pose *tmp ;
  int ind ;
  int i ;
  int imuIgnorepubsize ;
  int seq2 ;
  struct sensor_msgs_Imu_Pose *imuIgnore ;
  struct sensor_msgs_Imu_Pose *tmp___0 ;

  {
  pubsize = 0;
  seq = 1;
  tmp = (struct sensor_msgs_Imu_Pose *)malloc(sizeof(sensor_msgs_Imu_Pose ) + sizeof(double ) * 9UL);
  imu = tmp;
  pubsize = (unsigned long )pubsize + sizeof(sensor_msgs_Imu_Pose );
  ind = 0;
  while (ind < 9) {
    ind += 4;
  }
  i = 0;
  while (i < 50) {
    publish("imu", pubsize, seq);
    loopRate_sleep(50);
    seq ++;
    i ++;
  }
  imuIgnorepubsize = 0;
  seq2 = 1;
  tmp___0 = (struct sensor_msgs_Imu_Pose *)malloc(sizeof(sensor_msgs_Imu_Pose ) + sizeof(double ) * 9UL);
  imuIgnore = tmp___0;
  imuIgnorepubsize = (unsigned long )imuIgnorepubsize + sizeof(sensor_msgs_Imu_Pose );
  i = 0;
  i = 0;
  while (i < 50) {
    publish("imuIgnore", imuIgnorepubsize, seq2);
    loopRate_sleep(50);
    seq2 ++;
    i ++;
  }
  return;
}
}
void ImuTwistBasicIOTEST(void) 
{ 
  int pubsize ;
  int seq ;
  struct sensor_msgs_Imu_Twist *imu ;
  struct sensor_msgs_Imu_Twist *tmp ;
  int ind ;
  int i ;
  int imuIgnorepubsize ;
  int seq2 ;
  struct sensor_msgs_Imu_Twist *imuIgnore ;
  struct sensor_msgs_Imu_Twist *tmp___0 ;

  {
  pubsize = 0;
  seq = 1;
  tmp = (struct sensor_msgs_Imu_Twist *)malloc(sizeof(sensor_msgs_Imu_Twist ) + sizeof(double ) * 9UL);
  imu = tmp;
  pubsize = (unsigned long )pubsize + sizeof(sensor_msgs_Imu_Twist );
  ind = 0;
  ind = 0;
  while (ind < 9) {
    ind += 4;
  }
  i = 0;
  i = 0;
  while (i < 50) {
    publish("imu", pubsize, seq);
    loopRate_sleep(50);
    seq ++;
    i ++;
  }
  i = 0;
  while (i < 50) {
    publish("imu", pubsize, seq);
    loopRate_sleep(50);
    seq ++;
    i ++;
  }
  i = 0;
  while (i < 50) {
    publish("imu", pubsize, seq);
    seq ++;
    i ++;
  }
  imuIgnorepubsize = 0;
  seq2 = 1;
  tmp___0 = (struct sensor_msgs_Imu_Twist *)malloc(sizeof(sensor_msgs_Imu_Twist ));
  imuIgnore = tmp___0;
  imuIgnorepubsize = (unsigned long )imuIgnorepubsize + sizeof(sensor_msgs_Imu_Twist );
  i = 0;
  while (i < 50) {
    publish("imuIgnore", imuIgnorepubsize, seq2);
    loopRate_sleep(50);
    seq2 ++;
    i ++;
  }
  return;
}
}
void ImuAccBasicIOTEST(void) 
{ 
  int pubsize ;
  int seq ;
  struct sensor_msgs_Imu_Acc *imu ;
  struct sensor_msgs_Imu_Acc *tmp ;
  int i ;
  int imuIgnorepubsize ;
  int seq2 ;
  struct sensor_msgs_Imu_Acc *imuIgnore ;
  struct sensor_msgs_Imu_Acc *tmp___0 ;

  {
  pubsize = 0;
  seq = 1;
  tmp = (struct sensor_msgs_Imu_Acc *)malloc(sizeof(sensor_msgs_Imu_Acc ) + sizeof(double ) * 9UL);
  imu = tmp;
  pubsize = (unsigned long )pubsize + sizeof(sensor_msgs_Imu_Acc );
  i = 0;
  i = 0;
  while (i < 50) {
    publish("imu", pubsize, seq);
    loopRate_sleep(50);
    seq ++;
    i ++;
  }
  i = 0;
  while (i < 50) {
    publish("imu", pubsize, seq);
    loopRate_sleep(50);
    seq ++;
    i ++;
  }
  imuIgnorepubsize = 0;
  seq2 = 1;
  tmp___0 = (struct sensor_msgs_Imu_Acc *)malloc(sizeof(sensor_msgs_Imu_Acc ) + sizeof(double ) * 9UL);
  imuIgnore = tmp___0;
  imuIgnorepubsize = (unsigned long )imuIgnorepubsize + sizeof(sensor_msgs_Imu_Acc );
  i = 0;
  while (i < 50) {
    publish("imuIgnore", imuIgnorepubsize, seq2);
    loopRate_sleep(50);
    seq2 ++;
    i ++;
  }
  return;
}
}
void OdomDifferentialIOTEST(void) 
{ 
  int pubsize ;
  int seq ;
  struct nav_msgs_Odometry *odom ;
  struct nav_msgs_Odometry *tmp ;
  int zeroCount ;
  int tmp___0 ;
  int ind ;
  int i ;

  {
  pubsize = 0;
  seq = 1;
  tmp = (struct nav_msgs_Odometry *)malloc(sizeof(nav_msgs_Odometry ));
  odom = tmp;
  pubsize = (unsigned long )pubsize + sizeof(nav_msgs_Odometry );
  zeroCount = 0;
  while (1) {
    tmp___0 = zeroCount;
    zeroCount ++;
    if (! (tmp___0 < 10)) {
      break;
    }
    publish("odom", pubsize, seq);
    Duration_sleep(0.1);
    seq ++;
  }
  ind = 0;
  ind = 0;
  while (ind < 36) {
    ind += 7;
  }
  i = 0;
  i = 0;
  while (i < 100) {
    publish("odom", pubsize, seq);
    loopRate_sleep(20);
    seq ++;
    i ++;
  }
  return;
}
}
void PoseDifferentialIOTEST(void) 
{ 
  int pubsize ;
  int seq ;
  struct geometry_msgs_Pose *pose___0 ;
  struct geometry_msgs_Pose *tmp ;
  int zeroCount ;
  int tmp___0 ;
  int ind ;
  int i ;

  {
  pubsize = 0;
  seq = 1;
  tmp = (struct geometry_msgs_Pose *)malloc(sizeof(geometry_msgs_Pose ));
  pose___0 = tmp;
  pubsize = (unsigned long )pubsize + sizeof(geometry_msgs_Pose );
  zeroCount = 0;
  while (1) {
    tmp___0 = zeroCount;
    zeroCount ++;
    if (! (tmp___0 < 10)) {
      break;
    }
    publish("pose", pubsize, seq);
    Duration_sleep(0.1);
    seq ++;
  }
  ind = 0;
  ind = 0;
  while (ind < 36) {
    ind += 7;
  }
  i = 0;
  i = 0;
  while (i < 100) {
    publish("pose", pubsize, seq);
    loopRate_sleep(20);
    seq ++;
    i ++;
  }
  return;
}
}
void ImuDifferentialIOTEST(void) 
{ 
  int pubsize ;
  int seq ;
  struct sensor_msgs_Imu *imu ;
  struct sensor_msgs_Imu *tmp ;
  double roll ;
  double pitch ;
  double yaw ;
  int setCount ;
  int tmp___0 ;
  int zeroCount ;
  int tmp___1 ;
  double rollFinal ;
  double pitchFinal ;
  double yawFinal ;
  int i ;

  {
  pubsize = 0;
  seq = 1;
  tmp = (struct sensor_msgs_Imu *)malloc(sizeof(sensor_msgs_Imu ) + sizeof(double ) * 9UL);
  imu = tmp;
  pubsize = (unsigned long )pubsize + sizeof(sensor_msgs_Imu );
  roll = M_PI / 2.0;
  pitch = - M_PI;
  yaw = - M_PI / 4.0;
  setCount = 0;
  while (1) {
    tmp___0 = setCount;
    setCount ++;
    if (! (tmp___0 < 10)) {
      break;
    }
    publish("imu", pubsize, seq);
    publish("imu", pubsize, seq);
    Duration_sleep(0.1);
    seq ++;
  }
  zeroCount = 0;
  while (1) {
    tmp___1 = zeroCount;
    zeroCount ++;
    if (! (tmp___1 < 10)) {
      break;
    }
    publish("imu", pubsize, seq);
    Duration_sleep(0.1);
    seq ++;
  }
  rollFinal = roll;
  pitchFinal = pitch;
  yawFinal = yaw;
  i = 0;
  i = 0;
  while (i < 100) {
    yawFinal -= 0.01 * ((3.0 * M_PI) / 4.0);
    publish("imu", pubsize, seq);
    loopRate_sleep(20);
    seq ++;
    i ++;
  }
  i = 0;
  while (i < 100) {
    rollFinal += 0.01 * (M_PI / 2.0);
    publish("imu", pubsize, seq);
    loopRate_sleep(20);
    seq ++;
    i ++;
  }
  return;
}
}
void main(int argc , char **argv ) 
{ 


  {
  OdomPoseBasicIOTEST();
  OdomTwistBasicIOTEST();
  PoseBasicIOTEST();
  TwistBasicIOTEST();
  ImuPoseBasicIOTEST();
  ImuTwistBasicIOTEST();
  ImuAccBasicIOTEST();
  OdomDifferentialIOTEST();
  PoseDifferentialIOTEST();
  ImuDifferentialIOTEST();
  return;
}
}
