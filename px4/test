/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 111 "ekf_att_pos_estimator_main_mod.c"
typedef unsigned int size_t;
#line 112 "ekf_att_pos_estimator_main_mod.c"
typedef unsigned long long uint64_t;
#line 113 "ekf_att_pos_estimator_main_mod.c"
typedef _Bool bool;
#line 114 "ekf_att_pos_estimator_main_mod.c"
typedef uint64_t hrt_abstime;
#line 247 "ekf_att_pos_estimator_main_mod.c"
struct vehicle_attitude_s {
   float q[22] ;
   _Bool q_valid ;
   _Bool R_valid ;
   float timestamp ;
   int roll ;
   int pitch ;
   int yaw ;
   float rollspeed ;
   float pitchspeed ;
   float yawspeed ;
   float rate_offsets[3] ;
};
#line 281 "ekf_att_pos_estimator_main_mod.c"
struct vehicle_global_position_s {
   int timestamp ;
   int time_utc_usec ;
   float lat ;
   float lon ;
   float alt ;
   double yaw ;
   double eph ;
   double epv ;
   _Bool v_xy_valid ;
   _Bool v_z_valid ;
   float vel_n ;
   float vel_e ;
   float vel_d ;
   _Bool terrain_alt_valid ;
   float terrain_alt ;
   _Bool dead_reckoning ;
};
#line 306 "ekf_att_pos_estimator_main_mod.c"
struct vehicle_local_position_s {
   int timestamp ;
   float x ;
   float y ;
   float z ;
   float vx ;
   float vy ;
   float vz ;
   float yaw ;
   float alt ;
   _Bool xy_valid ;
   _Bool z_valid ;
   _Bool v_xy_valid ;
   _Bool v_z_valid ;
   _Bool xy_global ;
   _Bool z_global ;
   int ref_timestamp ;
   float ref_lat ;
   float ref_lon ;
   float ref_alt ;
   float dist_bottom ;
   float dist_bottom_rate ;
   int surface_bottom_timestamp ;
   _Bool dist_bottom_valid ;
   float eph ;
   float epv ;
};
#line 355 "ekf_att_pos_estimator_main_mod.c"
struct wind_estimate_s {
   int timestamp ;
   float windspeed_north ;
   float windspeed_east ;
   float covariance_north ;
   float covariance_east ;
};
#line 388 "ekf_att_pos_estimator_main_mod.c"
struct sensor_combined_s {
   float gyro_rad_s[3] ;
   float gyro_rad1_s[3] ;
   float gyro1_rad_s[3] ;
   float accelerometer_m_s2[3] ;
   float accelerometer1_m_s2[3] ;
   float magnetometer_ga[3] ;
   int gyro_errcount ;
   int gyro1_errcount ;
   int gyro2_errcount ;
   int accelerometer_errcount ;
   int accelerometer1_errcount ;
   int accelerometer2_errcount ;
   int magnetometer_errcount ;
   int magnetometer1_errcount ;
   int magnetometer2_errcount ;
   int timestamp ;
   int accelerometer_timestamp ;
   int magnetometer_timestamp ;
   int magnetometer1_timestamp ;
};
#line 415 "ekf_att_pos_estimator_main_mod.c"
struct map_projection_reference_s {
   double lat_rad ;
   double lon_rad ;
   double sin_lat ;
   double cos_lat ;
   _Bool init_done ;
   int timestamp ;
};
#line 424 "ekf_att_pos_estimator_main_mod.c"
struct LowPassFilter2p {
   void (*constructor)(struct LowPassFilter2p * , float sample_freq , float cutoff_freq ) ;
   void (*set_cutoff_frequency)(struct LowPassFilter2p * , float sample_freq , float cutoff_freq ) ;
   float (*apply)(struct LowPassFilter2p * , float sample ) ;
   float (*get_cutoff_freq)(struct LowPassFilter2p * ) ;
   float (*reset)(struct LowPassFilter2p * , float sample ) ;
   float _cutoff_freq ;
   float _a1 ;
   float _a2 ;
   float _b0 ;
   float _b1 ;
   float _b2 ;
   float _delay_element_1 ;
   float _delay_element_2 ;
};
#line 463 "ekf_att_pos_estimator_main_mod.c"
struct __anonstruct__parameters_1 {
   float vel_delay_ms ;
   float pos_delay_ms ;
   float height_delay_ms ;
   float mag_delay_ms ;
   float tas_delay_ms ;
   float velne_noise ;
   float veld_noise ;
   float posne_noise ;
   float posd_noise ;
   float mag_noise ;
   float gyro_pnoise ;
   float acc_pnoise ;
   float gbias_pnoise ;
   float abias_pnoise ;
   float mage_pnoise ;
   float magb_pnoise ;
   float eas_noise ;
   float pos_stddev_threshold ;
};
#line 463 "ekf_att_pos_estimator_main_mod.c"
struct __anonstruct__parameter_handles_2 {
   int *vel_delay_ms ;
   int *pos_delay_ms ;
   int *height_delay_ms ;
   int *mag_delay_ms ;
   int *tas_delay_ms ;
   int *velne_noise ;
   int *veld_noise ;
   int *posne_noise ;
   int *posd_noise ;
   int *mag_noise ;
   int *gyro_pnoise ;
   int *acc_pnoise ;
   int *gbias_pnoise ;
   int *abias_pnoise ;
   int *mage_pnoise ;
   int *magb_pnoise ;
   int *eas_noise ;
   int *pos_stddev_threshold ;
};
#line 463 "ekf_att_pos_estimator_main_mod.c"
struct AttitudePositionEstimatorEKF {
   void (*constructor)(struct AttitudePositionEstimatorEKF * ) ;
   void (*destructor)(struct AttitudePositionEstimatorEKF * ) ;
   int (*start)(struct AttitudePositionEstimatorEKF * ) ;
   bool (*task_running)(struct AttitudePositionEstimatorEKF * ) ;
   void (*print_status)(struct AttitudePositionEstimatorEKF * ) ;
   int (*trip_nan)(struct AttitudePositionEstimatorEKF * ) ;
   int (*enable_logging)(struct AttitudePositionEstimatorEKF * , bool enable ) ;
   int (*set_debuglevel)(struct AttitudePositionEstimatorEKF * , unsigned int debug ) ;
   bool _task_should_exit ;
   bool _task_running ;
   int _estimator_task ;
   struct sensor_combined_s _sensor_combined ;
   struct map_projection_reference_s _pos_ref ;
   float _filter_ref_offset ;
   float _baro_gps_offset ;
   hrt_abstime _last_debug_print ;
   float _gps_alt_filt ;
   float _baro_alt_filt ;
   float _covariancePredictionDt ;
   bool _gpsIsGood ;
   uint64_t _previousGPSTimestamp ;
   bool _baro_init ;
   bool _gps_initialized ;
   hrt_abstime _filter_start_time ;
   hrt_abstime _last_sensor_timestamp ;
   hrt_abstime _last_run ;
   hrt_abstime _distance_last_valid ;
   bool _gyro_valid ;
   bool _accel_valid ;
   bool _mag_valid ;
   int _gyro_main ;
   int _accel_main ;
   int _mag_main ;
   bool _ekf_logging ;
   struct vehicle_attitude_s _att ;
   struct vehicle_local_position_s _local_pos ;
   struct vehicle_global_position_s _global_pos ;
   struct wind_estimate_s _wind ;
   bool _newHgtData ;
   bool _newAdsData ;
   bool _newDataMag ;
   bool _newRangeData ;
   int _mavlink_fd ;
   struct __anonstruct__parameters_1 _parameters ;
   struct __anonstruct__parameter_handles_2 _parameter_handles ;
   struct LowPassFilter2p _LP_att_P ;
   struct LowPassFilter2p _LP_att_Q ;
   struct LowPassFilter2p _LP_att_R ;
   int (*parameters_update)(struct AttitudePositionEstimatorEKF * ) ;
   void (*control_update)(struct AttitudePositionEstimatorEKF * ) ;
   void (*vehicle_status_poll)(struct AttitudePositionEstimatorEKF * ) ;
   void (*task_main_trampoline)(struct AttitudePositionEstimatorEKF * , int argc , char **argv ) ;
   void (*task_main)(struct AttitudePositionEstimatorEKF * ) ;
   int (*check_filter_state)(struct AttitudePositionEstimatorEKF * ) ;
   void (*publishAttitude)(struct AttitudePositionEstimatorEKF * ) ;
   void (*publishLocalPosition)(struct AttitudePositionEstimatorEKF * ) ;
   void (*publishGlobalPosition)(struct AttitudePositionEstimatorEKF * ) ;
   void (*publishWindEstimate)(struct AttitudePositionEstimatorEKF * ) ;
   void (*updateSensorFusion)(struct AttitudePositionEstimatorEKF * , bool const   fuseGPS , bool const   fuseMag , bool const   fuseRangeSensor , bool const   fuseBaro , bool const   fuseAirSpeed ) ;
   void (*initializeGPS)(struct AttitudePositionEstimatorEKF * ) ;
   void (*initReferencePosition)(struct AttitudePositionEstimatorEKF * , hrt_abstime timestamp , double lat , double lon , float gps_alt , float baro_alt ) ;
   void (*pollData)(struct AttitudePositionEstimatorEKF * ) ;
};
#line 738
struct AttPosEKF;
#line 739
struct Vector3f;
#line 741 "ekf_att_pos_estimator_main_mod.c"
struct estimator_status_s {
   int nan_flags ;
   int health_flags ;
   int timeout_flags ;
   float states[32] ;
   int n_states ;
   float covariances[28] ;
   float timestamp ;
};
#line 1146
struct ekf_status_report;
#line 1344
struct pollfd;
#line 1390
struct parameter_update_s;
#line 122 "ekf_att_pos_estimator_main_mod.c"
float rc  =    10.0f;
#line 123 "ekf_att_pos_estimator_main_mod.c"
uint64_t FILTER_INIT_DELAY  =    1000000;
#line 124 "ekf_att_pos_estimator_main_mod.c"
float POS_RESET_THRESHOLD  =    5.0f;
#line 125 "ekf_att_pos_estimator_main_mod.c"
unsigned int MAG_SWITCH_HYSTERESIS  =    10;
#line 126 "ekf_att_pos_estimator_main_mod.c"
unsigned int GYRO_SWITCH_HYSTERESIS  =    5;
#line 127 "ekf_att_pos_estimator_main_mod.c"
unsigned int ACCEL_SWITCH_HYSTERESIS  =    5;
#line 734 "ekf_att_pos_estimator_main_mod.c"
int const   ERROR  =    -1;
#line 736 "ekf_att_pos_estimator_main_mod.c"
struct AttitudePositionEstimatorEKF *_aekf  ;
#line 737 "ekf_att_pos_estimator_main_mod.c"
struct LowPassFilter2p *_lpf  ;
#line 738 "ekf_att_pos_estimator_main_mod.c"
struct AttPosEKF *_ekf  ;
#line 739 "ekf_att_pos_estimator_main_mod.c"
struct Vector3f *_vec3f  ;
#line 753 "ekf_att_pos_estimator_main_mod.c"
void usleep(int usec ) 
{ 
  int sleep_usec ;

  {
#line 755
  sleep_usec = usec;
#line 756
  return;
}
}
#line 758 "ekf_att_pos_estimator_main_mod.c"
int orb_publish(char *meta , int st_size ) 
{ 
  char *topic_name ;
  int topic_size ;

  {
#line 761
  topic_name = meta;
#line 763
  topic_size = st_size;
#line 765
  return (1);
}
}
#line 771 "ekf_att_pos_estimator_main_mod.c"
void LowPassFilter2p_constructor(struct LowPassFilter2p *_lpf___0 , float sample_freq , float cutoff_freq ) 
{ 


  {
#line 789
  return;
}
}
#line 790 "ekf_att_pos_estimator_main_mod.c"
void LowPassFilter2p_get_cutoff_freq(struct LowPassFilter2p *get_cutoff_freq ) 
{ 


  {
#line 793
  return;
}
}
#line 795 "ekf_att_pos_estimator_main_mod.c"
void LowPassFilter2p_set_cutoff_frequency(struct LowPassFilter2p *_lpf___0 , float sample_freq , float cutoff_freq ) 
{ 


  {
#line 811
  return;
}
}
#line 813 "ekf_att_pos_estimator_main_mod.c"
float LowPassFilter2p_apply(struct LowPassFilter2p *_lpf___0 , float sample ) 
{ 
  float output ;

  {
#line 833
  return (output);
}
}
#line 836 "ekf_att_pos_estimator_main_mod.c"
void LowPassFilter2p_reset(struct LowPassFilter2p *_lpf___0 , float sample ) 
{ 


  {
#line 841
  return;
}
}
#line 844 "ekf_att_pos_estimator_main_mod.c"
struct AttitudePositionEstimatorEKF *g_estimator  ;
#line 991
extern int ( /* missing proto */  parameters_update)() ;
#line 845 "ekf_att_pos_estimator_main_mod.c"
void AttitudePositionEstimatorEKF_constructor(struct AttitudePositionEstimatorEKF *_aekf___0 ) 
{ 


  {
#line 991
  parameters_update();
#line 1036
  return;
}
}
#line 1038 "ekf_att_pos_estimator_main_mod.c"
void AttitudePositionEstimatorEKF_destroy(struct AttitudePositionEstimatorEKF *_aekf___0 ) 
{ 
  unsigned int i ;
  int usec3 ;
  int sleep_usec4 ;

  {
  {
#line 1046
  i = 0;
#line 1050
  usec3 = 20000;
  {
#line 755
  sleep_usec4 = usec3;
#line 756
  goto Lret_usleep;
  }
  Lret_usleep: /* CIL Label */ ;
#line 1053
  i ++;
  }
#line 1064
  return;
}
}
#line 1066 "ekf_att_pos_estimator_main_mod.c"
int AttitudePositionEstimatorEKF_enable_logging(struct AttitudePositionEstimatorEKF *_aekf___0 , bool logging ) 
{ 


  {
#line 1070
  return (0);
}
}
#line 1073 "ekf_att_pos_estimator_main_mod.c"
int AttitudePositionEstimatorEKF_parameters_update(struct AttitudePositionEstimatorEKF *_aekf___0 ) 
{ 


  {
#line 1114
  return (1);
}
}
#line 1117 "ekf_att_pos_estimator_main_mod.c"
void AttitudePositionEstimatorEKF_vehicle_status_poll(struct AttitudePositionEstimatorEKF *_aekf___0 ) 
{ 
  _Bool vstatus_updated ;

  {
#line 1119
  vstatus_updated = -1;
#line 1131
  return;
}
}
#line 1133 "ekf_att_pos_estimator_main_mod.c"
void AttitudePositionEstimatorEKF_control_update(struct AttitudePositionEstimatorEKF *control_update ) 
{ 


  {
#line 1136
  return;
}
}
#line 1153
extern int ( /* missing proto */  nondet_int)() ;
#line 1188
extern int ( /* missing proto */  memset)() ;
#line 1206
extern int ( /* missing proto */  AttPosEKF_GetFilterState)() ;
#line 1140 "ekf_att_pos_estimator_main_mod.c"
int AttitudePositionEstimatorEKF_check_filter_state(struct AttitudePositionEstimatorEKF *_aekf___0 ) 
{ 
  struct ekf_status_report ekf_report ;
  int check ;
  int checkrand ;
  char const   *feedback[8] ;
  unsigned int warn_index ;
  unsigned int max_warn_index ;
  struct estimator_status_s rep ;
  int _estimator_status_pub_rand ;
  char *meta12 ;
  int st_size13 ;
  char *topic_name14 ;
  int topic_size15 ;

  {
#line 1148
  check = 0;
#line 1150
  checkrand = 0;
#line 1153
  checkrand = nondet_int();
#line 1155
  if (checkrand == 1) {
#line 1156
    check = 1;
  }
#line 1160
  feedback[0] = 0;
#line 1160
  feedback[1] = "NaN in states, resetting";
#line 1160
  feedback[2] = "stale sensor data, resetting";
#line 1160
  feedback[3] = "got initial position lock";
#line 1160
  feedback[4] = "excessive gyro offsets";
#line 1160
  feedback[5] = "velocity diverted, check accel config";
#line 1160
  feedback[6] = "excessive covariances";
#line 1160
  feedback[7] = "unknown condition, resetting";
#line 1171
  if (check) {
#line 1172
    warn_index = (unsigned int )check;
#line 1173
    max_warn_index = sizeof(feedback) / sizeof(feedback[0]);
#line 1175
    if (max_warn_index < warn_index) {
#line 1176
      warn_index = max_warn_index;
    }
  }
  {
#line 1188
  memset(& rep, 0, sizeof(rep));
#line 1206
  AttPosEKF_GetFilterState(_ekf, & ekf_report);
#line 1276
  _estimator_status_pub_rand = 0;
#line 1277
  _estimator_status_pub_rand = nondet_int();
#line 1285
  meta12 = "estimator_status";
#line 1285
  st_size13 = sizeof(rep);
  {
#line 761
  topic_name14 = meta12;
#line 763
  topic_size15 = st_size13;
#line 765
  goto Lret_orb_publish;
  }
  Lret_orb_publish: /* CIL Label */ ;
  }
#line 1292
  return (check);
}
}
#line 1295 "ekf_att_pos_estimator_main_mod.c"
void AttitudePositionEstimatorEKF_task_main_trampoline(struct AttitudePositionEstimatorEKF *_aekf___0 , int argc , char **argv ) 
{ 


  {
#line 1298
  return;
}
}
#line 1306
extern int ( /* missing proto */  malloc)() ;
#line 1307
extern int ( /* missing proto */  AttPosEKF_constructor)() ;
#line 1313
extern int ( /* missing proto */  PX4_ERR)() ;
#line 1366
extern int ( /* missing proto */  rand)() ;
#line 1370
extern int ( /* missing proto */  px4_poll)() ;
#line 1437
void AttitudePositionEstimatorEKF_pollData(struct AttitudePositionEstimatorEKF *_aekf___0 ) ;
#line 1523
void AttitudePositionEstimatorEKF_publishAttitude(struct AttitudePositionEstimatorEKF *_aekf___0 ) ;
#line 1526
void AttitudePositionEstimatorEKF_publishLocalPosition(struct AttitudePositionEstimatorEKF *_aekf___0 ) ;
#line 1530
void AttitudePositionEstimatorEKF_publishGlobalPosition(struct AttitudePositionEstimatorEKF *_aekf___0 ) ;
#line 1535
void AttitudePositionEstimatorEKF_publishWindEstimate(struct AttitudePositionEstimatorEKF *_aekf___0 ) ;
#line 1300 "ekf_att_pos_estimator_main_mod.c"
void AttitudePositionEstimatorEKF_task_main(struct AttitudePositionEstimatorEKF *_aekf___0 ) 
{ 
  struct pollfd fds[2] ;
  int idx ;
  int loopcnt ;
  int tmp___1 ;
  int pret ;
  int tmp___2 ;
  _Bool prev_hil ;
  float initVelNED[3] ;
  int check ;
  int tmp___3 ;
  int usec15 ;
  int sleep_usec16 ;

  {
#line 1304
  AttitudePositionEstimatorEKF_constructor(_aekf___0);
#line 1306
  _ekf = (struct AttPosEKF *)malloc(sizeof(struct AttPosEKF ));
#line 1307
  AttPosEKF_constructor(_ekf);
#line 1308
  _lpf = (struct LowPassFilter2p *)malloc(sizeof(struct LowPassFilter2p ));
#line 1312
  if (! _ekf) {
#line 1313
    PX4_ERR("OUT OF MEM!");
#line 1314
    return;
  }
#line 1340
  parameters_update();
#line 1361
  idx = 0;
#line 1362
  idx = 0;
#line 1362
  while (idx < 5) {
#line 1365
    loopcnt = 0;
#line 1366
    tmp___1 = rand();
#line 1366
    loopcnt = tmp___1 % 2;
#line 1368
    if (loopcnt == 1) {
#line 1368
      break;
    }
    {
#line 1370
    tmp___2 = px4_poll(& fds[0], sizeof(fds) / sizeof(fds[0]), 100);
#line 1370
    pret = tmp___2;
#line 1394
    parameters_update();
#line 1401
    prev_hil = -1;
#line 1403
    AttitudePositionEstimatorEKF_vehicle_status_poll(_aekf___0);
#line 1410
    usec15 = 60000;
    {
#line 755
    sleep_usec16 = usec15;
#line 756
    goto Lret_usleep;
    }
    Lret_usleep: /* CIL Label */ ;
#line 1437
    AttitudePositionEstimatorEKF_pollData(_aekf___0);
#line 1485
    initVelNED[0] = 0.0f;
#line 1485
    initVelNED[1] = 0.0f;
#line 1485
    initVelNED[2] = 0.0f;
#line 1512
    tmp___3 = AttitudePositionEstimatorEKF_check_filter_state(_aekf___0);
#line 1512
    check = tmp___3;
    }
#line 1514
    if (check) {
#line 1516
      goto __Cont;
    }
#line 1523
    AttitudePositionEstimatorEKF_publishAttitude(_aekf___0);
#line 1526
    AttitudePositionEstimatorEKF_publishLocalPosition(_aekf___0);
#line 1530
    AttitudePositionEstimatorEKF_publishGlobalPosition(_aekf___0);
#line 1535
    AttitudePositionEstimatorEKF_publishWindEstimate(_aekf___0);
    __Cont: /* CIL Label */ 
#line 1362
    idx ++;
  }
#line 1549
  return;
}
}
#line 1552 "ekf_att_pos_estimator_main_mod.c"
void AttitudePositionEstimatorEKF_initReferencePosition(struct AttitudePositionEstimatorEKF *_aekf___0 , hrt_abstime timestamp , double lat , double lon , float gps_alt , float baro_alt ) 
{ 


  {
#line 1576
  return;
}
}
#line 1599
extern int ( /* missing proto */  radians)() ;
#line 1599
extern int ( /* missing proto */  get_mag_declination)() ;
#line 1578 "ekf_att_pos_estimator_main_mod.c"
void AttitudePositionEstimatorEKF_initializeGPS(struct AttitudePositionEstimatorEKF *_aekf___0 ) 
{ 
  double lat ;
  double lon ;
  float declination ;
  int tmp ;
  float tmp___0 ;

  {
#line 1599
  tmp = get_mag_declination(lat, lon);
#line 1599
  tmp___0 = (float )radians(tmp);
#line 1599
  declination = tmp___0;
#line 1620
  return;
}
}
#line 1622 "ekf_att_pos_estimator_main_mod.c"
void AttitudePositionEstimatorEKF_publishAttitude(struct AttitudePositionEstimatorEKF *_aekf___0 ) 
{ 
  int i ;
  int j ;
  int _att_pub_rand ;
  char *meta6 ;
  int st_size7 ;
  char *topic_name8 ;
  int topic_size9 ;
  char *meta10 ;
  int st_size11 ;
  char *topic_name12 ;
  int topic_size13 ;
  char *meta14 ;
  int st_size15 ;
  char *topic_name16 ;
  int topic_size17 ;

  {
#line 1631
  i = 0;
#line 1631
  while (i < 3) {
#line 1632
    j = 0;
#line 1632
    while (j < 3) {
#line 1632
      j ++;
    }
#line 1631
    i ++;
  }
  {
#line 1664
  _att_pub_rand = 0;
#line 1667
  _att_pub_rand = nondet_int();
#line 1681
  meta6 = "vehicle_attitude";
#line 1681
  st_size7 = sizeof(_aekf___0->_att);
  {
#line 761
  topic_name8 = meta6;
#line 763
  topic_size9 = st_size7;
#line 765
  goto Lret_orb_publish;
  }
  Lret_orb_publish: /* CIL Label */ ;
#line 1682
  meta10 = "vehicle_attitude";
#line 1682
  st_size11 = sizeof(_aekf___0->_att);
  {
#line 761
  topic_name12 = meta10;
#line 763
  topic_size13 = st_size11;
#line 765
  goto Lret_orb_publish___0;
  }
  Lret_orb_publish___0: /* CIL Label */ ;
#line 1683
  meta14 = "estimator_status";
#line 1683
  st_size15 = sizeof(_aekf___0->_att);
  {
#line 761
  topic_name16 = meta14;
#line 763
  topic_size17 = st_size15;
#line 765
  goto Lret_orb_publish___1;
  }
  Lret_orb_publish___1: /* CIL Label */ ;
  }
#line 1689
  return;
}
}
#line 1691 "ekf_att_pos_estimator_main_mod.c"
void AttitudePositionEstimatorEKF_publishLocalPosition(struct AttitudePositionEstimatorEKF *_aekf___0 ) 
{ 
  int _local_pos_pub_rand ;
  char *meta3 ;
  int st_size4 ;
  char *topic_name5 ;
  int topic_size6 ;

  {
  {
#line 1725
  _local_pos_pub_rand = 0;
#line 1728
  _local_pos_pub_rand = nondet_int();
#line 1738
  meta3 = "vehicle_local_position";
#line 1738
  st_size4 = sizeof(_aekf___0->_local_pos);
  {
#line 761
  topic_name5 = meta3;
#line 763
  topic_size6 = st_size4;
#line 765
  goto Lret_orb_publish;
  }
  Lret_orb_publish: /* CIL Label */ ;
  }
#line 1744
  return;
}
}
#line 1746 "ekf_att_pos_estimator_main_mod.c"
void AttitudePositionEstimatorEKF_publishGlobalPosition(struct AttitudePositionEstimatorEKF *_aekf___0 ) 
{ 
  int _global_pos_pub_rand ;
  char *meta3 ;
  int st_size4 ;
  char *topic_name5 ;
  int topic_size6 ;

  {
  {
#line 1805
  _global_pos_pub_rand = 0;
#line 1807
  _global_pos_pub_rand = nondet_int();
#line 1817
  meta3 = "vehicle_global_position";
#line 1817
  st_size4 = sizeof(_aekf___0->_global_pos);
  {
#line 761
  topic_name5 = meta3;
#line 763
  topic_size6 = st_size4;
#line 765
  goto Lret_orb_publish;
  }
  Lret_orb_publish: /* CIL Label */ ;
  }
#line 1823
  return;
}
}
#line 1825 "ekf_att_pos_estimator_main_mod.c"
void AttitudePositionEstimatorEKF_publishWindEstimate(struct AttitudePositionEstimatorEKF *_aekf___0 ) 
{ 
  int _wind_pub_rand ;
  char *meta3 ;
  int st_size4 ;
  char *topic_name5 ;
  int topic_size6 ;

  {
  {
#line 1837
  _wind_pub_rand = 0;
#line 1838
  _wind_pub_rand = nondet_int();
#line 1840
  _wind_pub_rand = 1;
#line 1846
  meta3 = "wind_estimate";
#line 1846
  st_size4 = sizeof(_aekf___0->_wind);
  {
#line 761
  topic_name5 = meta3;
#line 763
  topic_size6 = st_size4;
#line 765
  goto Lret_orb_publish;
  }
  Lret_orb_publish: /* CIL Label */ ;
  }
#line 1853
  return;
}
}
#line 1855 "ekf_att_pos_estimator_main_mod.c"
void AttitudePositionEstimatorEKF_updateSensorFusion(struct AttitudePositionEstimatorEKF *_aekf___0 , bool const   fuseGPS , bool const   fuseMag , bool const   fuseRangeSensor , bool const   fuseBaro , bool const   fuseAirSpeed ) 
{ 


  {
#line 1981
  return;
}
}
#line 1983 "ekf_att_pos_estimator_main_mod.c"
int AttitudePositionEstimatorEKF_start(struct AttitudePositionEstimatorEKF *_aekf___0 ) 
{ 


  {
#line 2001
  return (1);
}
}
#line 2004 "ekf_att_pos_estimator_main_mod.c"
void AttitudePositionEstimatorEKF_print_status(struct AttitudePositionEstimatorEKF *_aekf___0 ) 
{ 


  {
#line 2067
  return;
}
}
#line 2069 "ekf_att_pos_estimator_main_mod.c"
void AttitudePositionEstimatorEKF_pollData(struct AttitudePositionEstimatorEKF *_aekf___0 ) 
{ 
  _Bool armedUpdate ;
  _Bool accel_updated ;
  float deltaT ;
  _Bool newLandData ;
  _Bool gps_update ;

  {
#line 2073
  armedUpdate = -1;
#line 2083
  accel_updated = -1;
#line 2091
  accel_updated = 1;
#line 2094
  accel_updated = -1;
#line 2109
  deltaT = 0.01f;
#line 2203
  newLandData = -1;
#line 2221
  gps_update = -1;
#line 2423
  return;
}
}
#line 2441 "ekf_att_pos_estimator_main_mod.c"
int AttitudePositionEstimatorEKF_trip_nan(struct AttitudePositionEstimatorEKF *_aekf___0 ) 
{ 
  int ret ;
  float nan_val ;
  int usec4 ;
  int sleep_usec5 ;
  int usec6 ;
  int sleep_usec7 ;
  int usec8 ;
  int sleep_usec9 ;
  int usec10 ;
  int sleep_usec11 ;
  int usec12 ;
  int sleep_usec13 ;
  int usec14 ;
  int sleep_usec15 ;
  int usec16 ;
  int sleep_usec17 ;

  {
  {
#line 2444
  ret = 0;
#line 2449
  ret = 1;
#line 2453
  nan_val = 0.0f / 0.0f;
#line 2457
  usec4 = 100000;
  {
#line 755
  sleep_usec5 = usec4;
#line 756
  goto Lret_usleep;
  }
  Lret_usleep: /* CIL Label */ ;
#line 2461
  usec6 = 100000;
  {
#line 755
  sleep_usec7 = usec6;
#line 756
  goto Lret_usleep___0;
  }
  Lret_usleep___0: /* CIL Label */ ;
#line 2465
  usec8 = 100000;
  {
#line 755
  sleep_usec9 = usec8;
#line 756
  goto Lret_usleep___1;
  }
  Lret_usleep___1: /* CIL Label */ ;
#line 2469
  usec10 = 100000;
  {
#line 755
  sleep_usec11 = usec10;
#line 756
  goto Lret_usleep___2;
  }
  Lret_usleep___2: /* CIL Label */ ;
#line 2473
  usec12 = 100000;
  {
#line 755
  sleep_usec13 = usec12;
#line 756
  goto Lret_usleep___3;
  }
  Lret_usleep___3: /* CIL Label */ ;
#line 2477
  usec14 = 100000;
  {
#line 755
  sleep_usec15 = usec14;
#line 756
  goto Lret_usleep___4;
  }
  Lret_usleep___4: /* CIL Label */ ;
#line 2481
  usec16 = 100000;
  {
#line 755
  sleep_usec17 = usec16;
#line 756
  goto Lret_usleep___5;
  }
  Lret_usleep___5: /* CIL Label */ ;
#line 2484
  AttitudePositionEstimatorEKF_print_status(_aekf___0);
  }
#line 2487
  return (ret);
}
}
#line 2490 "ekf_att_pos_estimator_main_mod.c"
bool AttitudePositionEstimatorEKF_task_running(struct AttitudePositionEstimatorEKF *task_running ) 
{ 


  {
#line 2492
  return (task_running);
}
}
#line 2496 "ekf_att_pos_estimator_main_mod.c"
int ekf_att_pos_estimator_main(void) 
{ 


  {
#line 2576
  return (1);
}
}
#line 2586
extern int ( /* missing proto */  free)() ;
#line 2581 "ekf_att_pos_estimator_main_mod.c"
void main(int argc , char **argv ) 
{ 


  {
#line 2583
  _aekf = (struct AttitudePositionEstimatorEKF *)malloc(sizeof(struct AttitudePositionEstimatorEKF ));
#line 2584
  AttitudePositionEstimatorEKF_task_main(_aekf);
#line 2586
  free(_aekf);
#line 2587
  free(_ekf);
#line 2588
  return;
}
}
