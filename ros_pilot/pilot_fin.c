/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#pragma pack(4)
struct header {
   char *frame_id ;
   int stamp ;
   int seq ;
};
struct Config {
   int acceleration_controller ;
   double brake_hold ;
   double brake_kd ;
   double brake_ki ;
   double brake_kp ;
   _Bool human_steering ;
   double limit_forward ;
   double limit_reverse ;
   double throttle_kd ;
   double throttle_ki ;
   double throttle_kp ;
   double timeout ;
};
struct Epsilonst {
   float brake_position ;
   float distance ;
   float float_value ;
   float speed ;
   float steering_angle ;
   float throttle_position ;
};
struct driver_state {
   int state ;
};
struct PilotState {
   struct header *header ;
   int pilot_state ;
   int brake_state ;
   int imu_state ;
   int odom_state ;
   int shifter_state ;
   int steering_state ;
   int throttle_state ;
   int preempted ;
   float target_speed ;
   float target_acceleration ;
   float target_jerk ;
   float target_steering_angle ;
   int target_gear_value ;
   int target_behavior_value ;
   float plan_speed ;
   float plan_acceleration ;
   float plan_jerk ;
   float plan_steering_angle ;
   int plan_gear_value ;
   int plan_behavior_value ;
   float current_speed ;
   float current_acceleration ;
   float current_jerk ;
   float current_steering_angle ;
   int current_gear_value ;
   int current_behavior_value ;
};
typedef struct PilotState PilotState;
#pragma pack(4)
struct position {
   double x ;
};
#pragma pack(4)
struct orientation {
   double x ;
   double y ;
   double z ;
   double w ;
};
#pragma pack(4)
struct linear {
   double x ;
   double y ;
   double z ;
};
#pragma pack(4)
#pragma pack(4)
struct angular {
   double x ;
   double y ;
   double z ;
};
#pragma pack(4)
#pragma pack(4)
struct pose {
   struct pose *pose ;
   struct position *position ;
   struct orientation *orientation ;
   double covariance[36] ;
};
#pragma pack(4)
struct twist {
   struct twist *twist ;
   struct linear *linear ;
   struct angular *angular ;
   double covariance[36] ;
};
#pragma pack(4)
struct nav_msgs_Odometry {
   struct nav_msgs_Odometry *nav_msgs_Odometry ;
   struct pose *pose ;
   struct twist *twist ;
   struct header *header ;
   char *child_frame_id ;
};
#pragma pack(4)
#pragma pack(4)
#pragma pack(4)
#pragma pack(4)
#pragma pack(4)
#pragma pack(4)
struct sensor_msgs_Imu {
   struct orientation *orientation ;
   double orientation_covariance[9] ;
   double angular_velocity_covariance[9] ;
   struct header *header ;
};
#pragma pack(4)
struct ros_Publisher {
   char *topic ;
   int queuesize ;
};
typedef struct ros_Publisher ros_Publisher;
#pragma pack(4)
struct ros_Subscriber {
   char *topic ;
   int queuesize ;
};
typedef struct ros_Subscriber ros_Subscriber;
struct devicebrake {
   char *header_frame_id ;
   int header_stamp ;
   int header_seq ;
   int brake_command_request ;
   float brake_command_position ;
   float brake_state_position ;
   float brake_state_potentiometer ;
   float brake_state_encoder ;
   float brake_state_pressure ;
};
struct deviceimu {
   struct sensor_msgs_Imu *msg ;
};
struct deviceodom {
   struct nav_msgs_Odometry *msg ;
};
struct shifter {
   char *header_frame_id ;
   int header_stamp ;
   int header_seq ;
   int gear ;
   int relays ;
};
struct deviceshifter {
   struct shifter *cmd ;
   struct shifter *msg ;
   struct ros_Publisher *pub ;
   float shift_duration ;
   float shift_time ;
   _Bool is_reset ;
   _Bool busy ;
};
struct steering_command {
   struct header *header ;
   int request ;
   float angle ;
};
struct steering_state {
   struct header *header ;
   struct driver_state *driver ;
   float angle ;
   float sensor ;
};
struct devicesteering {
   struct steering_command *cmd ;
   struct steering_state *msg ;
};
struct throttle_command {
   struct header *header ;
   int request ;
   float position ;
};
struct throttle_state {
   struct header *header ;
   float position ;
   float rpms ;
   int estop ;
   float pwm ;
   float dstate ;
   float istate ;
};
struct devicethrottle {
   struct throttle_command *cmd ;
   struct throttle_state *msg ;
};
int mystrcmp(char const   *s , char const   *t ) ;
void nh_serviceClient(void) ;
struct ros_Publisher *nh_advertise(char *topic_name , int queue_size ) ;
struct ros_Subscriber *nh_subscribe(char *topic_name , int queue_size ) ;
void Duration_sleep(double seconds ) ;
void loopRate_sleep(int fq ) ;
void publish(char *meta , int size , int seq ) ;
struct driver_state *DriverState  ;
struct Epsilonst *Epsilon  ;
_Bool is_shifting_  ;
struct ros_Subscriber *accel_cmd_  ;
struct ros_Subscriber *car_cmd_  ;
struct devicebrake *brake_  ;
struct deviceimu *imu_  ;
struct deviceodom *odom_  ;
struct deviceshifter *shifter_  ;
struct devicesteering *steering_  ;
struct devicethrottle *throttle_  ;
struct ros_Subscriber *learning_cmd_  ;
struct ros_Publisher *pilot_state_  ;
struct Config *config_  ;
int current_time_  ;
int mystrcmp(char const   *s , char const   *t ) 
{ 
  int i ;

  {
  i = 0;
  while ((int const   )*(s + i) == (int const   )*(t + i)) {
    if ((int const   )*(s + i) == 0) {
      return (0);
    }
    i ++;
  }
  return ((int const   )*(s + i) - (int const   )*(t + i));
}
}
void nh_serviceClient(void) 
{ 


  {
  return;
}
}
extern int ( /* missing proto */  malloc)() ;
struct ros_Publisher *nh_advertise(char *topic_name , int queue_size ) 
{ 
  struct ros_Publisher *pub ;
  struct ros_Publisher *tmp ;

  {
  tmp = (struct ros_Publisher *)malloc(sizeof(ros_Publisher ));
  pub = tmp;
  pub->topic = topic_name;
  pub->queuesize = queue_size;
  return (pub);
}
}
struct ros_Subscriber *nh_subscribe(char *topic_name , int queue_size ) 
{ 
  struct ros_Subscriber *sub ;
  struct ros_Subscriber *tmp ;

  {
  tmp = (struct ros_Subscriber *)malloc(sizeof(ros_Subscriber ));
  sub = tmp;
  sub->topic = topic_name;
  sub->queuesize = queue_size;
  return (sub);
}
}
void Duration_sleep(double seconds ) 
{ 
  double sec ;

  {
  sec = seconds;
  return;
}
}
void loopRate_sleep(int fq ) 
{ 
  int sleep_fq ;

  {
  sleep_fq = 0;
  sleep_fq = fq;
  return;
}
}
void publish(char *meta , int size , int seq ) 
{ 
  char *topic ;
  int topic_size ;

  {
  topic = meta;
  topic_size = size;
  return;
}
}
void adjustSteering(PilotState *pstate_msg_ ) 
{ 
  float steer_degrees ;
  char *meta3 ;
  int size4 ;
  int seq5 ;
  char *topic6 ;
  int topic_size7 ;

  {
  {
  meta3 = "steering";
  size4 = sizeof(steer_degrees);
  seq5 = current_time_;
  {
  topic6 = meta3;
  topic_size7 = size4;
  goto Lret_publish;
  }
  Lret_publish: /* CIL Label */ ;
  }
  return;
}
}
void accel_reset(void) 
{ 


  {
  return;
}
}
void accel_adjust(struct PilotState *p , struct devicebrake *b , struct devicethrottle *t ) 
{ 


  {
  return;
}
}
void halt(void) 
{ 
  char *meta1 ;
  int size2 ;
  int seq3 ;
  char *topic4 ;
  int topic_size5 ;
  char *meta6 ;
  int size7 ;
  int seq8 ;
  char *topic9 ;
  int topic_size10 ;
  char *meta11 ;
  int size12 ;
  int seq13 ;
  char *topic14 ;
  int topic_size15 ;

  {
  {
  meta1 = "brake";
  size2 = sizeof(config_->brake_hold);
  seq3 = current_time_;
  {
  topic4 = meta1;
  topic_size5 = size2;
  goto Lret_publish;
  }
  Lret_publish: /* CIL Label */ ;
  meta6 = "throttle";
  size7 = sizeof(0.0);
  seq8 = current_time_;
  {
  topic9 = meta6;
  topic_size10 = size7;
  goto Lret_publish___0;
  }
  Lret_publish___0: /* CIL Label */ ;
  meta11 = "brake";
  size12 = sizeof(1.0);
  seq13 = current_time_;
  {
  topic14 = meta11;
  topic_size15 = size12;
  goto Lret_publish___1;
  }
  Lret_publish___1: /* CIL Label */ ;
  }
  return;
}
}
void monitorHardware(void) 
{ 


  {
  return;
}
}
extern int ( /* missing proto */  fabs)() ;
void validateTarget(PilotState *pstate_msg_ ) 
{ 


  {
  if ((double )pstate_msg_->target_speed < 0.0) {
    pstate_msg_->target_speed = (float )fabs(pstate_msg_->target_speed);
    pstate_msg_->target_acceleration = (float )fabs(pstate_msg_->target_acceleration);
    pstate_msg_->target_jerk = (float )fabs(pstate_msg_->target_jerk);
  } else
  if ((double )pstate_msg_->target_acceleration < 0.0) {
    pstate_msg_->target_speed = (float )fabs(pstate_msg_->target_speed);
    pstate_msg_->target_acceleration = (float )fabs(pstate_msg_->target_acceleration);
    pstate_msg_->target_jerk = (float )fabs(pstate_msg_->target_jerk);
  } else
  if ((double )pstate_msg_->target_jerk < 0.0) {
    pstate_msg_->target_speed = (float )fabs(pstate_msg_->target_speed);
    pstate_msg_->target_acceleration = (float )fabs(pstate_msg_->target_acceleration);
    pstate_msg_->target_jerk = (float )fabs(pstate_msg_->target_jerk);
  }
  if (pstate_msg_->target_gear_value == 2) {
    if ((double )pstate_msg_->target_speed > config_->limit_reverse) {
      pstate_msg_->target_speed = config_->limit_reverse;
    }
  } else
  if ((double )pstate_msg_->target_speed > config_->limit_forward) {
    pstate_msg_->target_speed = config_->limit_forward;
  }
  return;
}
}
void processCarDrive(PilotState *pstate_msg_ ) 
{ 


  {
  return;
}
}
void processCarCommand(PilotState *pstate_msg_ ) 
{ 


  {
  pstate_msg_->target_steering_angle = 1;
  pstate_msg_->target_behavior_value = 1;
  pstate_msg_->target_jerk = 0.0;
  pstate_msg_->target_acceleration = 0.0;
  if ((double )pstate_msg_->target_speed > 0.0) {
    pstate_msg_->target_gear_value = 4;
  } else
  if ((double )pstate_msg_->target_speed < 0.0) {
    pstate_msg_->target_speed = 1;
    pstate_msg_->target_gear_value = 1;
  } else {
    pstate_msg_->target_gear_value = 0;
  }
  return;
}
}
void PilotNodeConstructor(PilotState *pstate_msg_ ) 
{ 
  int qDepth ;

  {
  qDepth = 1;
  processCarDrive(pstate_msg_);
  return;
}
}
void speedControl(PilotState *pstate_msg_ ) 
{ 
  char *meta2 ;
  int size3 ;
  int seq4 ;
  char *topic5 ;
  int topic_size6 ;
  char *meta7 ;
  int size8 ;
  int seq9 ;
  char *topic10 ;
  int topic_size11 ;

  {
  {
  meta2 = "shifter";
  size3 = sizeof(int );
  seq4 = current_time_;
  {
  topic5 = meta2;
  topic_size6 = size3;
  goto Lret_publish;
  }
  Lret_publish: /* CIL Label */ ;
  halt();
  halt();
  meta7 = "shifter";
  size8 = sizeof(pstate_msg_->target_gear_value);
  seq9 = current_time_;
  {
  topic10 = meta7;
  topic_size11 = size8;
  goto Lret_publish___0;
  }
  Lret_publish___0: /* CIL Label */ ;
  halt();
  }
  return;
}
}
void PilotNode_spin(PilotState *p ) 
{ 
  char *meta2 ;
  int size3 ;
  int seq4 ;
  char *topic5 ;
  int topic_size6 ;

  {
  {
  monitorHardware();
  speedControl(p);
  adjustSteering(p);
  meta2 = "pilot_state";
  size3 = sizeof(PilotState );
  seq4 = 1;
  {
  topic5 = meta2;
  topic_size6 = size3;
  goto Lret_publish;
  }
  Lret_publish: /* CIL Label */ ;
  }
  return;
}
}
int main(int argc , char **argv ) 
{ 
  struct PilotState *pstate_msg_ ;
  struct PilotState *tmp ;

  {
  tmp = (struct PilotState *)malloc(sizeof(PilotState ));
  pstate_msg_ = tmp;
  PilotNodeConstructor(pstate_msg_);
  PilotNode_spin(pstate_msg_);
  return (0);
}
}
