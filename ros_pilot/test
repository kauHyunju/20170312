/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 35 "pilot.c"
#pragma pack(4)
#line 36 "pilot.c"
struct header {
   char *frame_id ;
   int stamp ;
   int seq ;
};
#line 45 "pilot.c"
struct Config {
   int acceleration_controller ;
   double brake_hold ;
   double brake_kd ;
   double brake_ki ;
   double brake_kp ;
   _Bool human_steering ;
   double limit_forward ;
   double limit_reverse ;
   double throttle_kd ;
   double throttle_ki ;
   double throttle_kp ;
   double timeout ;
};
#line 60 "pilot.c"
struct Epsilonst {
   float brake_position ;
   float distance ;
   float float_value ;
   float speed ;
   float steering_angle ;
   float throttle_position ;
};
#line 69 "pilot.c"
struct driver_state {
   int state ;
};
#line 109 "pilot.c"
struct PilotState {
   struct header *header ;
   int pilot_state ;
   int brake_state ;
   int imu_state ;
   int odom_state ;
   int shifter_state ;
   int steering_state ;
   int throttle_state ;
   int preempted ;
   float target_speed ;
   float target_acceleration ;
   float target_jerk ;
   float target_steering_angle ;
   int target_gear_value ;
   int target_behavior_value ;
   float plan_speed ;
   float plan_acceleration ;
   float plan_jerk ;
   float plan_steering_angle ;
   int plan_gear_value ;
   int plan_behavior_value ;
   float current_speed ;
   float current_acceleration ;
   float current_jerk ;
   float current_steering_angle ;
   int current_gear_value ;
   int current_behavior_value ;
};
#line 109 "pilot.c"
typedef struct PilotState PilotState;
#line 174
#pragma pack(4)
#line 175 "pilot.c"
struct position {
   double x ;
};
#line 181
#pragma pack(4)
#line 182 "pilot.c"
struct orientation {
   double x ;
   double y ;
   double z ;
   double w ;
};
#line 189
#pragma pack(4)
#line 190 "pilot.c"
struct linear {
   double x ;
   double y ;
   double z ;
};
#line 196
#pragma pack(4)
#line 203
#pragma pack(4)
#line 204 "pilot.c"
struct angular {
   double x ;
   double y ;
   double z ;
};
#line 210
#pragma pack(4)
#line 218
#pragma pack(4)
#line 219 "pilot.c"
struct pose {
   struct pose *pose ;
   struct position *position ;
   struct orientation *orientation ;
   double covariance[36] ;
};
#line 226
#pragma pack(4)
#line 227 "pilot.c"
struct twist {
   struct twist *twist ;
   struct linear *linear ;
   struct angular *angular ;
   double covariance[36] ;
};
#line 235
#pragma pack(4)
#line 236 "pilot.c"
struct nav_msgs_Odometry {
   struct nav_msgs_Odometry *nav_msgs_Odometry ;
   struct pose *pose ;
   struct twist *twist ;
   struct header *header ;
   char *child_frame_id ;
};
#line 246
#pragma pack(4)
#line 257
#pragma pack(4)
#line 267
#pragma pack(4)
#line 275
#pragma pack(4)
#line 283
#pragma pack(4)
#line 290
#pragma pack(4)
#line 291 "pilot.c"
struct sensor_msgs_Imu {
   struct orientation *orientation ;
   double orientation_covariance[9] ;
   double angular_velocity_covariance[9] ;
   struct header *header ;
};
#line 298
#pragma pack(4)
#line 299 "pilot.c"
struct ros_Publisher {
   char *topic ;
   int queuesize ;
};
#line 299 "pilot.c"
typedef struct ros_Publisher ros_Publisher;
#line 304
#pragma pack(4)
#line 305 "pilot.c"
struct ros_Subscriber {
   char *topic ;
   int queuesize ;
};
#line 305 "pilot.c"
typedef struct ros_Subscriber ros_Subscriber;
#line 334 "pilot.c"
struct devicebrake {
   char *header_frame_id ;
   int header_stamp ;
   int header_seq ;
   int brake_command_request ;
   float brake_command_position ;
   float brake_state_position ;
   float brake_state_potentiometer ;
   float brake_state_encoder ;
   float brake_state_pressure ;
};
#line 350 "pilot.c"
struct deviceimu {
   struct sensor_msgs_Imu *msg ;
};
#line 354 "pilot.c"
struct deviceodom {
   struct nav_msgs_Odometry *msg ;
};
#line 358 "pilot.c"
struct shifter {
   char *header_frame_id ;
   int header_stamp ;
   int header_seq ;
   int gear ;
   int relays ;
};
#line 372 "pilot.c"
struct deviceshifter {
   struct shifter *cmd ;
   struct shifter *msg ;
   struct ros_Publisher *pub ;
   float shift_duration ;
   float shift_time ;
   _Bool is_reset ;
   _Bool busy ;
};
#line 382 "pilot.c"
struct steering_command {
   struct header *header ;
   int request ;
   float angle ;
};
#line 388 "pilot.c"
struct steering_state {
   struct header *header ;
   struct driver_state *driver ;
   float angle ;
   float sensor ;
};
#line 396 "pilot.c"
struct devicesteering {
   struct steering_command *cmd ;
   struct steering_state *msg ;
};
#line 401 "pilot.c"
struct throttle_command {
   struct header *header ;
   int request ;
   float position ;
};
#line 407 "pilot.c"
struct throttle_state {
   struct header *header ;
   float position ;
   float rpms ;
   int estop ;
   float pwm ;
   float dstate ;
   float istate ;
};
#line 417 "pilot.c"
struct devicethrottle {
   struct throttle_command *cmd ;
   struct throttle_state *msg ;
};
#line 423
int mystrcmp(char const   *s , char const   *t ) ;
#line 426
void nh_serviceClient(void) ;
#line 428
struct ros_Publisher *nh_advertise(char *topic_name , int queue_size ) ;
#line 429
struct ros_Subscriber *nh_subscribe(char *topic_name , int queue_size ) ;
#line 432
void Duration_sleep(double seconds ) ;
#line 433
void loopRate_sleep(int fq ) ;
#line 434
void publish(char *meta , int size , int seq ) ;
#line 437 "pilot.c"
struct driver_state *DriverState  ;
#line 438 "pilot.c"
struct Epsilonst *Epsilon  ;
#line 476 "pilot.c"
_Bool is_shifting_  ;
#line 483 "pilot.c"
struct ros_Subscriber *accel_cmd_  ;
#line 486 "pilot.c"
struct ros_Subscriber *car_cmd_  ;
#line 489 "pilot.c"
struct devicebrake *brake_  ;
#line 490 "pilot.c"
struct deviceimu *imu_  ;
#line 491 "pilot.c"
struct deviceodom *odom_  ;
#line 492 "pilot.c"
struct deviceshifter *shifter_  ;
#line 493 "pilot.c"
struct devicesteering *steering_  ;
#line 494 "pilot.c"
struct devicethrottle *throttle_  ;
#line 497 "pilot.c"
struct ros_Subscriber *learning_cmd_  ;
#line 499 "pilot.c"
struct ros_Publisher *pilot_state_  ;
#line 502 "pilot.c"
struct Config *config_  ;
#line 503 "pilot.c"
int current_time_  ;
#line 530 "pilot.c"
int mystrcmp(char const   *s , char const   *t ) 
{ 
  int i ;

  {
#line 534
  i = 0;
#line 534
  while ((int const   )*(s + i) == (int const   )*(t + i)) {
#line 536
    if ((int const   )*(s + i) == 0) {
#line 538
      return (0);
    }
#line 534
    i ++;
  }
#line 540
  return ((int const   )*(s + i) - (int const   )*(t + i));
}
}
#line 543 "pilot.c"
void nh_serviceClient(void) 
{ 


  {
#line 544
  return;
}
}
#line 547
extern int ( /* missing proto */  malloc)() ;
#line 546 "pilot.c"
struct ros_Publisher *nh_advertise(char *topic_name , int queue_size ) 
{ 
  struct ros_Publisher *pub ;
  struct ros_Publisher *tmp ;

  {
#line 547
  tmp = (struct ros_Publisher *)malloc(sizeof(ros_Publisher ));
#line 547
  pub = tmp;
#line 549
  pub->topic = topic_name;
#line 550
  pub->queuesize = queue_size;
#line 551
  return (pub);
}
}
#line 554 "pilot.c"
struct ros_Subscriber *nh_subscribe(char *topic_name , int queue_size ) 
{ 
  struct ros_Subscriber *sub ;
  struct ros_Subscriber *tmp ;

  {
#line 555
  tmp = (struct ros_Subscriber *)malloc(sizeof(ros_Subscriber ));
#line 555
  sub = tmp;
#line 560
  sub->topic = topic_name;
#line 561
  sub->queuesize = queue_size;
#line 562
  return (sub);
}
}
#line 565 "pilot.c"
void Duration_sleep(double seconds ) 
{ 
  double sec ;

  {
#line 567
  sec = seconds;
#line 569
  return;
}
}
#line 571 "pilot.c"
void loopRate_sleep(int fq ) 
{ 
  int sleep_fq ;

  {
#line 572
  sleep_fq = 0;
#line 573
  sleep_fq = fq;
#line 589
  return;
}
}
#line 591 "pilot.c"
void publish(char *meta , int size , int seq ) 
{ 
  char *topic ;
  int topic_size ;

  {
#line 593
  topic = meta;
#line 596
  topic_size = size;
#line 629
  return;
}
}
#line 648 "pilot.c"
void adjustSteering(PilotState *pstate_msg_ ) 
{ 
  float steer_degrees ;

  {
#line 661
  publish("steering", sizeof(steer_degrees), current_time_);
#line 663
  return;
}
}
#line 681 "pilot.c"
void accel_reset(void) 
{ 


  {
#line 682
  return;
}
}
#line 684 "pilot.c"
void accel_adjust(struct PilotState *p , struct devicebrake *b , struct devicethrottle *t ) 
{ 


  {
#line 686
  return;
}
}
#line 688 "pilot.c"
void halt(void) 
{ 


  {
#line 697
  publish("brake", sizeof(config_->brake_hold), current_time_);
#line 707
  publish("throttle", sizeof(0.0), current_time_);
#line 708
  publish("brake", sizeof(1.0), current_time_);
#line 711
  return;
}
}
#line 719 "pilot.c"
void monitorHardware(void) 
{ 


  {
#line 720
  return;
}
}
#line 774
extern int ( /* missing proto */  fabs)() ;
#line 765 "pilot.c"
void validateTarget(PilotState *pstate_msg_ ) 
{ 


  {
#line 768
  if ((double )pstate_msg_->target_speed < 0.0) {
#line 774
    pstate_msg_->target_speed = (float )fabs(pstate_msg_->target_speed);
#line 775
    pstate_msg_->target_acceleration = (float )fabs(pstate_msg_->target_acceleration);
#line 776
    pstate_msg_->target_jerk = (float )fabs(pstate_msg_->target_jerk);
  } else
#line 768
  if ((double )pstate_msg_->target_acceleration < 0.0) {
#line 774
    pstate_msg_->target_speed = (float )fabs(pstate_msg_->target_speed);
#line 775
    pstate_msg_->target_acceleration = (float )fabs(pstate_msg_->target_acceleration);
#line 776
    pstate_msg_->target_jerk = (float )fabs(pstate_msg_->target_jerk);
  } else
#line 768
  if ((double )pstate_msg_->target_jerk < 0.0) {
#line 774
    pstate_msg_->target_speed = (float )fabs(pstate_msg_->target_speed);
#line 775
    pstate_msg_->target_acceleration = (float )fabs(pstate_msg_->target_acceleration);
#line 776
    pstate_msg_->target_jerk = (float )fabs(pstate_msg_->target_jerk);
  }
#line 779
  if (pstate_msg_->target_gear_value == 2) {
#line 781
    if ((double )pstate_msg_->target_speed > config_->limit_reverse) {
#line 788
      pstate_msg_->target_speed = config_->limit_reverse;
    }
  } else
#line 793
  if ((double )pstate_msg_->target_speed > config_->limit_forward) {
#line 800
    pstate_msg_->target_speed = config_->limit_forward;
  }
#line 810
  return;
}
}
#line 813 "pilot.c"
void processCarDrive(PilotState *pstate_msg_ ) 
{ 


  {
#line 818
  return;
}
}
#line 821 "pilot.c"
void processCarCommand(PilotState *pstate_msg_ ) 
{ 


  {
#line 826
  pstate_msg_->target_steering_angle = 1;
#line 827
  pstate_msg_->target_behavior_value = 1;
#line 829
  pstate_msg_->target_jerk = 0.0;
#line 830
  pstate_msg_->target_acceleration = 0.0;
#line 832
  if ((double )pstate_msg_->target_speed > 0.0) {
#line 835
    pstate_msg_->target_gear_value = 4;
  } else
#line 838
  if ((double )pstate_msg_->target_speed < 0.0) {
#line 841
    pstate_msg_->target_speed = 1;
#line 842
    pstate_msg_->target_gear_value = 1;
  } else {
#line 846
    pstate_msg_->target_gear_value = 0;
  }
#line 850
  return;
}
}
#line 871 "pilot.c"
void PilotNodeConstructor(PilotState *pstate_msg_ ) 
{ 
  int qDepth ;

  {
#line 889
  qDepth = 1;
#line 893
  processCarDrive(pstate_msg_);
#line 902
  return;
}
}
#line 932 "pilot.c"
void speedControl(PilotState *pstate_msg_ ) 
{ 


  {
#line 954
  publish("shifter", sizeof(int ), current_time_);
#line 968
  halt();
#line 980
  halt();
#line 996
  publish("shifter", sizeof(pstate_msg_->target_gear_value), current_time_);
#line 999
  halt();
#line 1001
  return;
}
}
#line 1005 "pilot.c"
void PilotNode_spin(PilotState *p ) 
{ 


  {
#line 1013
  monitorHardware();
#line 1016
  speedControl(p);
#line 1017
  adjustSteering(p);
#line 1019
  publish("pilot_state", sizeof(PilotState ), 1);
#line 1023
  return;
}
}
#line 1028 "pilot.c"
int main(int argc , char **argv ) 
{ 
  struct PilotState *pstate_msg_ ;
  struct PilotState *tmp ;

  {
#line 1036
  tmp = (struct PilotState *)malloc(sizeof(PilotState ));
#line 1036
  pstate_msg_ = tmp;
#line 1037
  PilotNodeConstructor(pstate_msg_);
#line 1038
  PilotNode_spin(pstate_msg_);
#line 1040
  return (0);
}
}
