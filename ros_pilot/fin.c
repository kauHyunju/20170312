/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#pragma pack(4)
struct header {
   char *frame_id ;
   int stamp ;
   int seq ;
};
struct Config {
   int acceleration_controller ;
   double brake_hold ;
   double brake_kd ;
   double brake_ki ;
   double brake_kp ;
   _Bool human_steering ;
   double limit_forward ;
   double limit_reverse ;
   double throttle_kd ;
   double throttle_ki ;
   double throttle_kp ;
   double timeout ;
};
struct Epsilonst {
   float brake_position ;
   float distance ;
   float float_value ;
   float speed ;
   float steering_angle ;
   float throttle_position ;
};
struct driver_state {
   int state ;
};
struct PilotState {
   struct header *header ;
   int pilot_state ;
   int brake_state ;
   int imu_state ;
   int odom_state ;
   int shifter_state ;
   int steering_state ;
   int throttle_state ;
   int preempted ;
   float target_speed ;
   float target_acceleration ;
   float target_jerk ;
   float target_steering_angle ;
   int target_gear_value ;
   int target_behavior_value ;
   float plan_speed ;
   float plan_acceleration ;
   float plan_jerk ;
   float plan_steering_angle ;
   int plan_gear_value ;
   int plan_behavior_value ;
   float current_speed ;
   float current_acceleration ;
   float current_jerk ;
   float current_steering_angle ;
   int current_gear_value ;
   int current_behavior_value ;
};
typedef struct PilotState PilotState;
#pragma pack(4)
struct position {
   double x ;
};
#pragma pack(4)
struct orientation {
   double x ;
   double y ;
   double z ;
   double w ;
};
#pragma pack(4)
struct linear {
   double x ;
   double y ;
   double z ;
};
#pragma pack(4)
#pragma pack(4)
struct angular {
   double x ;
   double y ;
   double z ;
};
#pragma pack(4)
#pragma pack(4)
struct pose {
   struct pose *pose ;
   struct position *position ;
   struct orientation *orientation ;
   double covariance[36] ;
};
#pragma pack(4)
struct twist {
   struct twist *twist ;
   struct linear *linear ;
   struct angular *angular ;
   double covariance[36] ;
};
#pragma pack(4)
struct nav_msgs_Odometry {
   struct nav_msgs_Odometry *nav_msgs_Odometry ;
   struct pose *pose ;
   struct twist *twist ;
   struct header *header ;
   char *child_frame_id ;
};
#pragma pack(4)
#pragma pack(4)
#pragma pack(4)
#pragma pack(4)
#pragma pack(4)
#pragma pack(4)
struct sensor_msgs_Imu {
   struct orientation *orientation ;
   double orientation_covariance[9] ;
   double angular_velocity_covariance[9] ;
   struct header *header ;
};
#pragma pack(4)
struct ros_Publisher {
   char *topic ;
   int queuesize ;
};
typedef struct ros_Publisher ros_Publisher;
#pragma pack(4)
struct ros_Subscriber {
   char *topic ;
   int queuesize ;
};
typedef struct ros_Subscriber ros_Subscriber;
struct devicebrake {
   char *header_frame_id ;
   int header_stamp ;
   int header_seq ;
   int brake_command_request ;
   float brake_command_position ;
   float brake_state_position ;
   float brake_state_potentiometer ;
   float brake_state_encoder ;
   float brake_state_pressure ;
};
struct deviceimu {
   struct sensor_msgs_Imu *msg ;
};
struct deviceodom {
   struct nav_msgs_Odometry *msg ;
};
struct shifter {
   char *header_frame_id ;
   int header_stamp ;
   int header_seq ;
   int gear ;
   int relays ;
};
struct deviceshifter {
   struct shifter *cmd ;
   struct shifter *msg ;
   struct ros_Publisher *pub ;
   float shift_duration ;
   float shift_time ;
   _Bool is_reset ;
   _Bool busy ;
};
struct steering_command {
   struct header *header ;
   int request ;
   float angle ;
};
struct steering_state {
   struct header *header ;
   struct driver_state *driver ;
   float angle ;
   float sensor ;
};
struct devicesteering {
   struct steering_command *cmd ;
   struct steering_state *msg ;
};
struct throttle_command {
   struct header *header ;
   int request ;
   float position ;
};
struct throttle_state {
   struct header *header ;
   float position ;
   float rpms ;
   int estop ;
   float pwm ;
   float dstate ;
   float istate ;
};
struct devicethrottle {
   struct throttle_command *cmd ;
   struct throttle_state *msg ;
};
int mystrcmp(char const   *s , char const   *t ) ;
void nh_serviceClient(void) ;
struct ros_Publisher *nh_advertise(char *topic_name , int queue_size ) ;
struct ros_Subscriber *nh_subscribe(char *topic_name , int queue_size ) ;
void Duration_sleep(double seconds ) ;
void loopRate_sleep(int fq ) ;
void publish(char *meta , int size , int seq ) ;
struct driver_state *DriverState  ;
struct Epsilonst *Epsilon  ;
_Bool is_shifting_  ;
struct ros_Subscriber *accel_cmd_  ;
struct ros_Subscriber *car_cmd_  ;
struct devicebrake *brake_  ;
struct deviceimu *imu_  ;
struct deviceodom *odom_  ;
struct deviceshifter *shifter_  ;
struct devicesteering *steering_  ;
struct devicethrottle *throttle_  ;
struct ros_Subscriber *learning_cmd_  ;
struct ros_Publisher *pilot_state_  ;
struct Config *config_  ;
int current_time_  ;
int mystrcmp(char const   *s , char const   *t ) 
{ 
  int i ;

  {
  i = 0;
  while ((int const   )*(s + i) == (int const   )*(t + i)) {
    if ((int const   )*(s + i) == 0) {
      return (0);
    }
    i ++;
  }
  return ((int const   )*(s + i) - (int const   )*(t + i));
}
}
void nh_serviceClient(void) 
{ 


  {
  return;
}
}
extern int ( /* missing proto */  malloc)() ;
struct ros_Publisher *nh_advertise(char *topic_name , int queue_size ) 
{ 
  struct ros_Publisher *pub ;
  struct ros_Publisher *tmp ;

  {
  tmp = (struct ros_Publisher *)malloc(sizeof(ros_Publisher ));
  pub = tmp;
  pub->topic = topic_name;
  pub->queuesize = queue_size;
  return (pub);
}
}
struct ros_Subscriber *nh_subscribe(char *topic_name , int queue_size ) 
{ 
  struct ros_Subscriber *sub ;
  struct ros_Subscriber *tmp ;

  {
  tmp = (struct ros_Subscriber *)malloc(sizeof(ros_Subscriber ));
  sub = tmp;
  sub->topic = topic_name;
  sub->queuesize = queue_size;
  return (sub);
}
}
void Duration_sleep(double seconds ) 
{ 
  double sec ;

  {
  sec = seconds;
  return;
}
}
void loopRate_sleep(int fq ) 
{ 
  int sleep_fq ;

  {
  sleep_fq = 0;
  sleep_fq = fq;
  return;
}
}
void publish(char *meta , int size , int seq ) 
{ 
  char *topic ;
  int topic_size ;

  {
  topic = meta;
  topic_size = size;
  return;
}
}
void adjustSteering(PilotState *pstate_msg_ ) 
{ 
  float steer_degrees ;

  {
  publish("steering", sizeof(steer_degrees), current_time_);
  return;
}
}
void accel_reset(void) 
{ 


  {
  return;
}
}
void accel_adjust(struct PilotState *p , struct devicebrake *b , struct devicethrottle *t ) 
{ 


  {
  return;
}
}
void halt(void) 
{ 


  {
  publish("brake", sizeof(config_->brake_hold), current_time_);
  publish("throttle", sizeof(0.0), current_time_);
  publish("brake", sizeof(1.0), current_time_);
  return;
}
}
void monitorHardware(void) 
{ 


  {
  return;
}
}
extern int ( /* missing proto */  fabs)() ;
void validateTarget(PilotState *pstate_msg_ ) 
{ 


  {
  if ((double )pstate_msg_->target_speed < 0.0) {
    pstate_msg_->target_speed = (float )fabs(pstate_msg_->target_speed);
    pstate_msg_->target_acceleration = (float )fabs(pstate_msg_->target_acceleration);
    pstate_msg_->target_jerk = (float )fabs(pstate_msg_->target_jerk);
  } else
  if ((double )pstate_msg_->target_acceleration < 0.0) {
    pstate_msg_->target_speed = (float )fabs(pstate_msg_->target_speed);
    pstate_msg_->target_acceleration = (float )fabs(pstate_msg_->target_acceleration);
    pstate_msg_->target_jerk = (float )fabs(pstate_msg_->target_jerk);
  } else
  if ((double )pstate_msg_->target_jerk < 0.0) {
    pstate_msg_->target_speed = (float )fabs(pstate_msg_->target_speed);
    pstate_msg_->target_acceleration = (float )fabs(pstate_msg_->target_acceleration);
    pstate_msg_->target_jerk = (float )fabs(pstate_msg_->target_jerk);
  }
  if (pstate_msg_->target_gear_value == 2) {
    if ((double )pstate_msg_->target_speed > config_->limit_reverse) {
      pstate_msg_->target_speed = config_->limit_reverse;
    }
  } else
  if ((double )pstate_msg_->target_speed > config_->limit_forward) {
    pstate_msg_->target_speed = config_->limit_forward;
  }
  return;
}
}
void processCarDrive(PilotState *pstate_msg_ ) 
{ 


  {
  return;
}
}
void processCarCommand(PilotState *pstate_msg_ ) 
{ 


  {
  pstate_msg_->target_steering_angle = 1;
  pstate_msg_->target_behavior_value = 1;
  pstate_msg_->target_jerk = 0.0;
  pstate_msg_->target_acceleration = 0.0;
  if ((double )pstate_msg_->target_speed > 0.0) {
    pstate_msg_->target_gear_value = 4;
  } else
  if ((double )pstate_msg_->target_speed < 0.0) {
    pstate_msg_->target_speed = 1;
    pstate_msg_->target_gear_value = 1;
  } else {
    pstate_msg_->target_gear_value = 0;
  }
  return;
}
}
void PilotNodeConstructor(PilotState *pstate_msg_ ) 
{ 
  int qDepth ;

  {
  qDepth = 1;
  processCarDrive(pstate_msg_);
  return;
}
}
void speedControl(PilotState *pstate_msg_ ) 
{ 


  {
  publish("shifter", sizeof(int ), current_time_);
  halt();
  halt();
  publish("shifter", sizeof(pstate_msg_->target_gear_value), current_time_);
  halt();
  return;
}
}
void PilotNode_spin(PilotState *p ) 
{ 


  {
  monitorHardware();
  speedControl(p);
  adjustSteering(p);
  publish("pilot_state", sizeof(PilotState ), 1);
  return;
}
}
int main(int argc , char **argv ) 
{ 
  struct PilotState *pstate_msg_ ;
  struct PilotState *tmp ;

  {
  tmp = (struct PilotState *)malloc(sizeof(PilotState ));
  pstate_msg_ = tmp;
  PilotNodeConstructor(pstate_msg_);
  PilotNode_spin(pstate_msg_);
  return (0);
}
}
